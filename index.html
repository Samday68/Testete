<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>VOLATILITY ANALYZER V.1.0</title>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    
    body { 
      font-family: sans-serif; 
      background: #1a1a1a; 
      color: #fff; 
      margin: 0; 
      padding: 5px; 
      transition: background-color 0.3s, color 0.3s; 
      overflow-x: hidden; 
      overflow-y: auto; 
    }
    
    body.day-mode { 
      background: #fff; 
      color: #000; 
    }
    
    #mainContainer { 
      display: flex; 
      gap: 8px; 
      max-width: 100%; 
      margin: 0 auto; 
    }
    
    #leftSection { 
      flex: 1; 
      min-width: 280px; 
      max-width: 100%; 
    }
    
    #rightSection { 
      flex: 0 0 85px; 
      display: flex; 
      flex-direction: column; 
      gap: 6px; 
      position: relative; 
    }
    
    @media (max-width: 768px) { 
      #mainContainer { gap: 5px; } 
      #leftSection { flex: 1; min-width: 0; } 
      #rightSection { flex: 0 0 70px; } 
      body { padding: 3px; } 
    }
    
    #headerSection { 
      text-align: center; 
      margin: 4px 0; 
      width: 100%; 
    }
    
    #headerLogo { 
      width: 100%; 
      height: 65px; 
      display: block; 
      object-fit: contain; 
      object-position: center; 
      margin: 0 auto; 
      transition: opacity 0.3s; 
    }
    
    @media (max-width: 768px) { 
      #headerLogo { height: 52px; } 
    }
    
    #toggleRow { 
      display: flex; 
      gap: 15px; 
      justify-content: center; 
      align-items: center; 
      margin: 4px auto; 
    }
    
    #graphToggle { 
      height: 20px; 
      font-size: 11px; 
      font-weight: 900; 
      padding: 0 10px; 
      cursor: pointer; 
      border: none; 
      border-radius: 5px; 
      background: #d93025; 
      color: #fff; 
    }
    
    #themeToggle { 
      width: 28px; 
      height: 28px; 
      border: none; 
      border-radius: 50%; 
      background: #333; 
      cursor: pointer; 
      font-size: 14px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      transition: background 0.3s; 
    }
    
    body.day-mode #themeToggle { 
      background: #ffd700; 
    }
    
    @media (max-width: 768px) { 
      #toggleRow { gap: 12px; } 
      #graphToggle { height: 18px; font-size: 10px; padding: 0 8px; } 
      #themeToggle { width: 24px; height: 24px; font-size: 12px; } 
    }
    
    #pairsWrap { 
      width: 100%; 
      margin: 4px 0; 
      display: flex; 
      align-items: center; 
      gap: 4px; 
      flex-wrap: nowrap; 
    }
    
    #pairs { 
      display: flex; 
      gap: 2px; 
      flex-wrap: nowrap; 
      flex: 1; 
    }
    
    .pair-btn { 
      padding: 6px 3px; 
      border: none; 
      border-radius: 5px; 
      background: #555; 
      color: #fff; 
      cursor: pointer; 
      font-size: 8.5px; 
      font-weight: 600; 
      flex: 1; 
      min-width: 45px; 
      transition: background 0.3s, color 0.3s; 
    }
    
    body.day-mode .pair-btn { 
      background: #e0e0e0; 
      color: #000; 
    }
    
    .pair-btn.active { 
      background: #000; 
      color: #fff; 
    }
    
    @media (max-width: 768px) { 
      .pair-btn { padding: 5px 2px; font-size: 7.5px; min-width: 38px; } 
    }
    
    #startStopBtn { 
      padding: 5px 10px; 
      font-size: 10px; 
      font-weight: 900; 
      cursor: pointer; 
      border: 2px solid #4CAF50; 
      border-radius: 15px; 
      background: #4CAF50; 
      color: #fff; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      gap: 3px; 
      white-space: nowrap; 
      flex-shrink: 0; 
    }
    
    #startStopBtn.stopped { 
      background: #d93025; 
      border-color: #d93025; 
    }
    
    @media (max-width: 768px) { 
      #startStopBtn { padding: 4px 8px; font-size: 9px; } 
    }
    
    #topbar { 
      display: flex; 
      gap: 3px; 
      margin: 4px 0; 
      align-items: center; 
      flex-wrap: wrap; 
    }
    
    #time { 
      background: #000; 
      color: #fff; 
      padding: 3px 6px; 
      border-radius: 3px; 
      font-weight: bold; 
      font-size: 9px; 
      white-space: nowrap; 
      height: 21px; 
      display: flex; 
      align-items: center; 
    }
    
    body.day-mode #time { 
      background: #333; 
    }
    
    #connectBtn { 
      background: #d93025; 
      color: #fff; 
      border: none; 
      padding: 3px 8px; 
      border-radius: 3px; 
      cursor: pointer; 
      font-weight: bold; 
      font-size: 9px; 
      white-space: nowrap; 
      height: 21px; 
      display: flex; 
      align-items: center; 
    }
    
    #apiInput { 
      flex: 1; 
      min-width: 80px; 
      background: #0b57d0; 
      color: #fff; 
      border: none; 
      padding: 3px 6px; 
      border-radius: 3px; 
      font-size: 9px; 
      height: 21px; 
    }
    
    #apiInput::placeholder { 
      color: #cce5ff; 
    }
    
    #saveGroup { 
      display: flex; 
      align-items: center; 
      gap: 3px; 
      padding: 0px 5px; 
      border-radius: 3px; 
      outline: 2px solid #fff; 
      height: 21px; 
    }
    
    body.day-mode #saveGroup { 
      outline: 2px solid #000; 
    }
    
    #saveCheckbox { 
      width: 13px; 
      height: 13px; 
      cursor: pointer; 
      accent-color: #0b57d0; 
      background: #fff; 
      border: 2px solid #fff; 
      border-radius: 2px; 
      padding: 2px; 
    }
    
    body.day-mode #saveCheckbox { 
      background: #fff; 
      border: 2px solid #000; 
    }
    
    #saveLabel { 
      font-size: 8px; 
      font-weight: bold; 
      cursor: pointer; 
      white-space: nowrap; 
      user-select: none; 
    }
    
    #price { 
      background: #0b57d0; 
      color: #fff; 
      padding: 3px 8px; 
      border-radius: 3px; 
      font-weight: bold; 
      font-size: 10px; 
      text-align: center; 
      white-space: nowrap; 
      height: 21px; 
      display: flex; 
      align-items: center; 
    }
    
    @media (max-width: 768px) { 
      #time, #connectBtn { font-size: 8px; padding: 2px 6px; height: 19px; } 
      #apiInput { font-size: 8px; padding: 2px 5px; min-width: 60px; height: 19px; } 
      #saveGroup { gap: 2px; padding: 0px 4px; height: 19px; } 
      #saveCheckbox { width: 12px; height: 12px; } 
      #saveLabel { font-size: 7px; } 
      #price { font-size: 9px; padding: 2px 6px; height: 19px; } 
    }
    
    #chartContainer { 
      position: relative; 
      width: 100%; 
    }
    
    #chart { 
      width: 100%; 
      height: 180px; 
      position: relative; 
      z-index: 2; 
    }
    
    @media (max-width: 768px) { 
      #chart { height: 130px; } 
    }
    
    #chartWatermark { 
      position: absolute; 
      left: 0; 
      top: 50%; 
      transform: translateY(-50%); 
      width: 100%; 
      height: 65px; 
      opacity: 0.18; 
      pointer-events: none; 
      z-index: 1; 
      object-fit: contain; 
      object-position: center; 
      transition: opacity 0.3s; 
    }
    
    @media (max-width: 768px) { 
      #chartWatermark { height: 52px; } 
    }
    
    #xzRowWrap { 
      width: 100%; 
      position: relative; 
      margin-top: 1px; 
    }
    
    #numbersTop { 
      display: flex; 
      flex-wrap: nowrap; 
      justify-content: flex-end; 
      overflow: hidden; 
      width: 100%; 
      position: relative; 
      padding: 3px 0; 
    }
    
    .num-box { 
      flex: 0 0 36px; 
      height: 22px; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      margin: 1px; 
      color: #fff; 
      font-size: 12px; 
      font-weight: bold; 
      border-radius: 3px; 
    }
    
    @media (max-width: 768px) { 
      .num-box { flex: 0 0 28px; height: 18px; font-size: 10px; margin: 0.5px; } 
    }
    
    .worm-line { 
      position: absolute; 
      height: 1px; 
      border-top: 2px solid; 
      z-index: 5; 
    }
    
    #gridWrap { 
      width: 100%; 
      position: relative; 
      margin-top: 2px; 
    }
    
    #gridTopRow, #gridBottomRow { 
      display: flex; 
      flex-wrap: nowrap; 
      justify-content: flex-end; 
      width: 100%; 
    }
    
    .grid-cell { 
      flex: 0 0 36px; 
      height: 36px; 
      box-sizing: border-box; 
      background: #1a1a1a; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: 900; 
      font-size: 16px; 
      line-height: 1; 
      padding: 0; 
      margin: 0; 
      border: 2px solid #444; 
      transition: background 0.3s, border-color 0.3s; 
    }
    
    body.day-mode .grid-cell { 
      background: #fff; 
      border-color: #000; 
    }
    
    @media (max-width: 768px) { 
      .grid-cell { flex: 0 0 28px; height: 28px; font-size: 13px; border: 1.5px solid #444; } 
      body.day-mode .grid-cell { border: 1.5px solid #000; } 
    }
    
    .grid-top { 
      border-color: #0b57d0; 
    }
    
    .grid-bottom { 
      border-color: #d93025; 
    }
    
    #gridDivider { 
      width: 100%; 
      display: flex; 
      justify-content: flex-end; 
      margin: 0; 
      height: 2px; 
      background: transparent; 
    }
    
    #gridDividerLine { 
      height: 2px; 
      background: #fff; 
      width: 0px; 
      transition: background 0.3s; 
    }
    
    body.day-mode #gridDividerLine { 
      background: #000; 
    }
    
    .start-box { 
      position: absolute; 
      border: 2px solid #fff; 
      pointer-events: none; 
      z-index: 50; 
      box-sizing: border-box; 
      transition: border-color 0.3s; 
    }
    
    body.day-mode .start-box { 
      border-color: #000; 
    }
    
    .start-label { 
      position: absolute; 
      top: -10px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: orange; 
      color: #000; 
      font-size: 8px; 
      font-weight: 900; 
      padding: 0 3px; 
      line-height: 10px; 
      border-radius: 2px; 
      white-space: nowrap; 
    }
    
    #analysisBoxes { 
      width: 100%; 
      margin-top: 2px; 
      position: relative; 
    }
    
    #xyBox { 
      position: relative; 
      width: 100%; 
      height: 340px; 
      border-bottom: 2px solid #444; 
      transition: border-color 0.3s; 
    }
    
    body.day-mode #xyBox { 
      border-bottom-color: #000; 
    }
    
    @media (max-width: 768px) { 
      #xyBox { height: 250px; } 
    }
    
    #xyCanvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
    }
    
    #trendAngleBox { 
      width: 100%; 
      height: 70px; 
      background: #1a1a1a; 
      border: 2px solid #444; 
      border-radius: 6px; 
      position: absolute; 
      top: 0; 
      right: 0; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: flex-start; 
      transition: background 0.3s, border-color 0.3s; 
    }
    
    body.day-mode #trendAngleBox { 
      background: #f5f5f5; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      #trendAngleBox { height: 55px; } 
    }
    
    #trendAngleCanvas { 
      width: 100%; 
      height: 50px; 
    }
    
    @media (max-width: 768box) { 
      #trendAngleCanvas { height: 38px; } 
    }
    
    #upDownSignalBox { 
      width: 90%; 
      height: 16px; 
      background: #333; 
      border-radius: 3px; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      margin-bottom: 2px; 
      transition: background 0.3s; 
    }
    
    body.day-mode #upDownSignalBox { 
      background: #ddd; 
    }
    
    #upDownSignalBox.signal-up { 
      background: #0066ff; 
    }
    
    #upDownSignalBox.signal-down { 
      background: #cc0000; 
    }
    
    #upDownSignalText { 
      font-size: 9px; 
      font-weight: 900; 
      color: #fff; 
      text-shadow: 1px 1px 1px rgba(0,0,0,0.5); 
    }
    
    body.day-mode #upDownSignalText { 
      color: #000; 
    }
    
    #upDownSignalBox.signal-up #upDownSignalText, 
    #upDownSignalBox.signal-down #upDownSignalText { 
      color: #fff; 
    }
    
    @media (max-width: 768px) { 
      #upDownSignalBox { height: 14px; } 
      #upDownSignalText { font-size: 8px; } 
    }
    
    #trendBellBox { 
      width: 100%; 
      height: 70px; 
      background: #666; 
      border: 2px solid #444; 
      border-radius: 6px; 
      position: absolute; 
      top: 76px; 
      right: 0; 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      gap: 4px; 
      transition: background 0.3s, border-color 0.3s; 
    }
    
    #trendBellBox.trend-up { 
      background: #0066ff; 
      border-color: #0044cc; 
    }
    
    #trendBellBox.trend-down { 
      background: #cc0000; 
      border-color: #990000; 
    }
    
    body.day-mode #trendBellBox { 
      background: #e0e0e0; 
      border-color: #ccc; 
    }
    
    body.day-mode #trendBellBox.trend-up { 
      background: #0066ff; 
      border-color: #0044cc; 
    }
    
    body.day-mode #trendBellBox.trend-down { 
      background: #cc0000; 
      border-color: #990000; 
    }
    
    @media (max-width: 768px) { 
      #trendBellBox { height: 55px; top: 61px; } 
    }
    
    #trendBellIcon { 
      font-size: 24px; 
      filter: drop-shadow(0 2px 3px rgba(0,0,0,0.3)); 
    }
    
    @media (max-width: 768px) { 
      #trendBellIcon { font-size: 20px; } 
    }
    
    #trendLabel { 
      font-size: 10px; 
      font-weight: 900; 
      color: #fff; 
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5); 
    }
    
    @media (max-width: 768box) { 
      #trendLabel { font-size: 9px; } 
    }
    
    #tradingPanel { 
      width: 100%; 
      background: #000; 
      border: 2px solid #666; 
      border-radius: 6px; 
      padding: 5px; 
      display: flex; 
      flex-direction: column; 
      gap: 4px; 
      position: absolute; 
      top: 152px; 
      right: 0; 
    }
    
    body.day-mode #tradingPanel { 
      background: #f5f5f5; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      #tradingPanel { top: 122px; padding: 4px; gap: 3px; border: 1.5px solid #666; } 
      body.day-mode #tradingPanel { border: 1.5px solid #ccc; } 
    }
    
    .panel-header-row { 
      display: flex; 
      justify-content: space-between; 
      align-items: flex-start; 
      width: 100%; 
      position: relative; 
      min-height: 24px; 
    }
    
    .duration-container {
      display: flex;
      flex-direction: column;
      gap: 1px;
      flex: 1;
      min-width: 0;
    }
    
    .panel-label { 
      font-size: 8px; 
      font-weight: bold; 
      white-space: nowrap; 
    }
    
    .panel-value { 
      background: #555; 
      color: #fff; 
      padding: 3px 6px; 
      border-radius: 4px; 
      text-align: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 1.5px solid #666; 
      min-width: 30px; 
    }
    
    body.day-mode .panel-value { 
      background: #fff; 
      color: #000; 
      border-color: #ccc; 
    }
    
    #autoTradeBtn { 
      position: absolute;
      top: 0;
      right: 0;
      width: 18px; 
      height: 9px; 
      border-radius: 4.5px; 
      border: 1px solid #666; 
      background: linear-gradient(to bottom, #444, #222); 
      color: #fff; 
      font-size: 4px; 
      font-weight: 900; 
      cursor: pointer; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      transition: all 0.3s; 
      padding: 0;
      letter-spacing: 0.5px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.5);
      z-index: 10;
    }
    
    #autoTradeBtn:hover {
      transform: translateY(-0.5px);
      box-shadow: 0 1.5px 3px rgba(0,0,0,0.6);
    }
    
    #autoTradeBtn:active {
      transform: translateY(0);
      box-shadow: 0 0.5px 1px rgba(0,0,0,0.4);
    }
    
    #autoTradeBtn.active { 
      background: linear-gradient(to bottom, #ff3333, #cc0000); 
      border-color: #990000; 
      color: #fff; 
      text-shadow: 0 0.5px 0.5px rgba(0,0,0,0.5);
      animation: autoPulse 1.5s infinite; 
    }
    
    @keyframes autoPulse { 
      0%, 100% { 
        opacity: 1; 
        box-shadow: 0 1px 2px rgba(204, 0, 0, 0.5);
      } 
      50% { 
        opacity: 0.85; 
        box-shadow: 0 1px 4px rgba(204, 0, 0, 0.7);
      } 
    }
    
    body.day-mode #autoTradeBtn { 
      background: linear-gradient(to bottom, #ddd, #bbb); 
      color: #000; 
      border-color: #999; 
      box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    }
    
    body.day-mode #autoTradeBtn.active { 
      background: linear-gradient(to bottom, #ff3333, #cc0000); 
      border-color: #990000; 
      color: #fff; 
    }
    
    .panel-row { 
      display: flex; 
      flex-direction: column; 
      gap: 1px; 
      margin-top: 2px; 
    }
    
    .panel-input { 
      background: #555; 
      color: #fff; 
      padding: 4px; 
      border-radius: 4px; 
      text-align: center; 
      font-size: 10px; 
      font-weight: bold; 
      border: 1.5px solid #666; 
      width: 100%; 
    }
    
    body.day-mode .panel-input { 
      background: #fff; 
      color: #000; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      .panel-label { font-size: 7px; } 
      .panel-value, .panel-input { 
        padding: 3px; 
        font-size: 9px; 
        border: 1px solid #666; 
      } 
      body.day-mode .panel-value, body.day-mode .panel-input { border: 1px solid #ccc; } 
      
      #autoTradeBtn {
        width: 16px;
        height: 8px;
        font-size: 3.5px;
        border-radius: 4px;
        border: 1px solid #666;
      }
      
      .panel-header-row {
        min-height: 22px;
      }
    }
    
    .trade-buttons { 
      display: flex; 
      flex-direction: column; 
      gap: 6px; 
      margin-top: 4px; 
    }
    
    @media (max-width: 768px) { 
      .trade-buttons { gap: 4px; margin-top: 2px; } 
    }
    
    .metal-btn { 
      width: 100%; 
      height: 42px; 
      border-radius: 50%; 
      position: relative; 
      border: none; 
      cursor: pointer; 
      background: radial-gradient(circle at 30% 30%, #ffffff, #bdbdbd 35%, #8f8f8f 55%, #f5f5f5 75%, #9b9b9b 100%); 
      box-shadow: inset 0 2px 5px rgba(255,255,255,.9), inset 0 -5px 8px rgba(0,0,0,.7), 0 8px 15px rgba(0,0,0,.9); 
    }
    
    @media (max-width: 768px) { 
      .metal-btn { height: 32px; box-shadow: inset 0 2px 4px rgba(255,255,255,.9), inset 0 -4px 6px rgba(0,0,0,.7), 0 6px 10px rgba(0,0,0,.9); } 
    }
    
    .metal-btn::before { 
      content: ""; 
      position: absolute; 
      inset: 5px; 
      border-radius: 50%; 
      background: linear-gradient(to bottom, var(--light) 0%, var(--mid) 48%, var(--dark) 100%); 
    }
    
    @media (max-width: 768px) { 
      .metal-btn::before { inset: 4px; } 
    }
    
    .metal-btn::after { 
      content: ""; 
      position: absolute; 
      inset: 7px; 
      border-radius: 50%; 
      background: linear-gradient(to bottom, rgba(255,255,255,.45) 0%, rgba(255,255,255,.35) 35%, rgba(255,255,255,0) 36%); 
      pointer-events: none; 
    }
    
    @media (max-width: 768px) { 
      .metal-btn::after { inset: 5px; } 
    }
    
    .up { 
      --light: #aebcff; 
      --mid: #1e3dff; 
      --dark: #0c1f7a; 
    }
    
    .down { 
      --light: #ffb8b8; 
      --mid: #c61f1f; 
      --dark: #6b0000; 
    }
    
    .metal-btn:active { 
      transform: translateY(2px); 
      box-shadow: inset 0 5px 10px rgba(0,0,0,.8), 0 5px 8px rgba(0,0,0,.8); 
    }
    
    .balance-row { 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      margin-top: 2px; 
    }
    
    .balance-label { 
      font-size: 8px; 
      font-weight: bold; 
    }
    
    .balance-value { 
      color: #4CAF50; 
      font-size: 8px; 
      font-weight: bold; 
    }
    
    @media (max-width: 768px) { 
      .balance-row { margin-top: 1px; } 
      .balance-label, .balance-value { font-size: 7px; } 
    }
    
    #tradeChart { 
      width: 100%; 
      height: 85px; 
      background: #1a1a1a; 
      border: 2px solid #666; 
      border-radius: 6px; 
      margin-top: 5px; 
      position: absolute; 
      top: 412px; 
      right: 0; 
      display: none; 
    }
    
    body.day-mode #tradeChart { 
      background: #f5f5f5; 
      border-color: #ccc; 
    }
    
    @media (max-width: 768px) { 
      #tradeChart { height: 70px; top: 312px; border: 1.5px solid #666; margin-top: 4px; } 
      body.day-mode #tradeChart { border: 1.5px solid #ccc; } 
    }
    
    #tradeCanvas { 
      width: 100%; 
      height: 100%; 
      display: block; 
    }
  </style>
</head>
<body>
  <div id="mainContainer">
    <div id="leftSection">
      <div id="headerSection">
        <img id="headerLogo" src="https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg" alt="logo" onerror="this.style.display='none';" />
      </div>
      <div id="toggleRow">
        <button id="graphToggle">XZ</button>
        <button id="themeToggle">üåô</button>
      </div>
      <div id="pairsWrap">
        <div id="pairs">
          <button class="pair-btn active" data-pair="R_100">100</button>
          <button class="pair-btn" data-pair="R_75">75</button>
          <button class="pair-btn" data-pair="R_50">50</button>
          <button class="pair-btn" data-pair="R_25">25</button>
          <button class="pair-btn" data-pair="R_10">10</button>
          <button class="pair-btn" data-pair="RDBEAR">BEAR</button>
          <button class="pair-btn" data-pair="RDBULL">BULL</button>
        </div>
        <button id="startStopBtn">
          <span>‚èª</span>
          <span id="startStopText">START</span>
        </button>
      </div>
      <div id="topbar">
        <div id="time">GMT 00:00:00</div>
        <button id="connectBtn">Connect</button>
        <input type="text" id="apiInput" placeholder="Enter Token_ID:">
        <div id="saveGroup">
          <input type="checkbox" id="saveCheckbox">
          <label id="saveLabel" for="saveCheckbox">Save</label>
        </div>
        <div id="price">0.00</div>
      </div>
      <div id="chartContainer">
        <img id="chartWatermark" src="https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg" alt="" onerror="this.style.display='none';" />
        <canvas id="chart"></canvas>
      </div>
      <div id="xzRowWrap">
        <div id="numbersTop"></div>
      </div>
      <div id="gridWrap">
        <div id="gridTopRow"></div>
        <div id="gridDivider"><div id="gridDividerLine"></div></div>
        <div id="gridBottomRow"></div>
      </div>
      <div id="analysisBoxes">
        <div id="xyBox">
          <canvas id="xyCanvas"></canvas>
        </div>
      </div>
    </div>
    <div id="rightSection">
      <div id="trendAngleBox">
        <canvas id="trendAngleCanvas"></canvas>
        <div id="upDownSignalBox">
          <span id="upDownSignalText">---</span>
        </div>
      </div>
      <div id="trendBellBox">
        <span id="trendBellIcon">üîî</span>
        <span id="trendLabel">Trend</span>
      </div>
      <div id="tradingPanel">
        <div class="panel-header-row">
          <div class="duration-container">
            <div class="panel-label">Duration:</div>
            <div class="panel-value">5</div>
          </div>
          <button id="autoTradeBtn">AUTO</button>
        </div>
        <div class="panel-row">
          <div class="panel-label">STAKE:</div>
          <input type="number" class="panel-input" id="stakeInput" value="1" min="0.35" step="0.01">
        </div>
        <div class="trade-buttons">
          <button class="metal-btn up" id="callBtn"></button>
          <button class="metal-btn down" id="putBtn"></button>
        </div>
        <div class="balance-row">
          <span class="balance-label">Balance:</span>
          <span class="balance-value" id="balanceValue">$ 0.00</span>
        </div>
        <div class="balance-row">
          <span class="balance-label">Profit:</span>
          <span class="balance-value" id="profitValue">$ 0.00</span>
        </div>
      </div>
      <div id="tradeChart">
        <canvas id="tradeCanvas"></canvas>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  
  <script>
    // ========== GLOBAL DEƒûƒ∞≈ûKENLER ==========
    let audioContext = null;
    let lastTrendSignal = null;
    let currentTrendData = { direction: null, last3: [], colors: [], arrows: [] };
    let trendStartGlobal = null;
    let currentUpDownSignal = null;
    let lastUpDownSignal = null;
    let autoTradeEnabled = false;
    let autoTradeInProgress = false;
    let ws = null;
    let derivWS = null;
    let apiToken = '';
    let isRunning = true;
    let prices = [];
    let digits = [];
    let decimalDigits = [];
    let combinedDigits = [];
    let wormLinesTop = [];
    let numColors = [];
    let currentPair = 'R_100';
    let currentGraph = 'XZ';
    let gridHistory = [];
    let startCooldown = 0;
    let xzTickCounter = 0;
    let startGlobalSpan = null;
    let tradeActive = false;
    let tradeType = '';
    let entrySpot = 0;
    let exitSpot = 0;
    let barrier = 0;
    let tradeData = [];
    let contractId = null;
    let chart = null;
    let lastStartGlobal = -100; // FIX: Ba≈ülangƒ±√ß deƒüeri

    // Yeni performans deƒüi≈ükenleri
    let analysisWorker = null;
    let lastRenderTime = 0;
    let renderThrottle = 16; // ~60 FPS
    let isPageVisible = true;
    let wsReconnectTimer = null;
    let pendingUpdates = [];
    let isProcessingUpdates = false;

    // ========== WEB WORKER OLU≈ûTURMA ==========
    function createAnalysisWorker() {
      if (window.Worker) {
        const workerCode = `
          self.onmessage = function(e) {
            const { type, data } = e.data;
            
            if (type === 'ANALYZE_TREND') {
              const result = analyzeTrend(data.gridHistory, data.startGlobalSpan, data.xzTickCounter);
              self.postMessage({ type: 'TREND_RESULT', result: result });
            }
            
            if (type === 'ANALYZE_UPDOWN') {
              const result = analyzeUpDownSignal(data.arrows);
              self.postMessage({ type: 'UPDOWN_RESULT', result: result });
            }
            
            if (type === 'PROCESS_GRID') {
              const result = processGridData(data.decimalDigits, data.numColors, data.xzTickCounter, data.lastStartGlobal);
              self.postMessage({ type: 'GRID_RESULT', result: result });
            }
          };
          
          function analyzeTrend(gridHistory, startGlobalSpan, xzTickCounter) {
            if (!startGlobalSpan || gridHistory.length < 6) return null;
            const vis = gridHistory.length;
            const firstGlobal = xzTickCounter - vis;
            const startFrom = startGlobalSpan.to - firstGlobal + 1;
            if (startFrom < 0 || startFrom >= vis - 2) return null;
            
            const afterStart = [];
            for (let i = startFrom; i < vis; i++) {
              afterStart.push({
                v: gridHistory[i].v,
                row: gridHistory[i].row,
                color: gridHistory[i].effColor
              });
            }
            
            if (afterStart.length < 3) return null;
            const last3 = afterStart.slice(-3);
            const v1 = last3[0].v, v2 = last3[1].v, v3 = last3[2].v;
            const c1 = last3[0].color, c2 = last3[1].color, c3 = last3[2].color;
            
            const compare12 = v2 > v1 ? 'up' : (v2 < v1 ? 'down' : 'flat');
            const compare23 = v3 > v2 ? 'up' : (v3 < v2 ? 'down' : 'flat');
            const compare13 = v3 > v1 ? 'up' : (v3 < v1 ? 'down' : 'flat');
            
            let trendDirection = null;
            
            if (compare12 === 'up' && compare23 === 'up' && compare13 === 'up') {
              trendDirection = 'UP';
            } else if (compare12 === 'down' && compare23 === 'down' && compare13 === 'down') {
              trendDirection = 'DOWN';
            } else if (compare12 === 'down' && compare23 === 'up') {
              if (v3 > v1 || v3 >= v2) trendDirection = 'UP';
            } else if (compare12 === 'up' && compare23 === 'down') {
              if (v3 < v1 || v3 <= v2) trendDirection = 'DOWN';
            } else {
              const blueCount = [c1, c2, c3].filter(c => c === 'blue').length;
              const redCount = [c1, c2, c3].filter(c => c === 'red').length;
              if (blueCount >= 2 && compare13 === 'up') trendDirection = 'UP';
              else if (redCount >= 2 && compare13 === 'down') trendDirection = 'DOWN';
            }
            
            return {
              direction: trendDirection,
              last3: [v1, v2, v3],
              colors: [c1, c2, c3]
            };
          }
          
          function analyzeUpDownSignal(arrows) {
            if (!arrows || arrows.length < 2) return null;
            const lastArrows = arrows.slice(-3);
            if (lastArrows.length < 2) return null;
            let upCount = 0;
            let downCount = 0;
            lastArrows.forEach(arrow => {
              if (arrow === 'up') upCount++;
              else if (arrow === 'down') downCount++;
            });
            if (upCount >= 2 && downCount >= 1) return 'UP';
            if (downCount >= 2 && upCount >= 1) return 'DOWN';
            return null;
          }
          
          function processGridData(decimalDigits, numColors, xzTickCounter, lastStartGlobal) {
            const vis = Math.min(11, decimalDigits.length);
            if (vis <= 0) return { gridHistory: [], startGlobalSpan: null };
            
            const decSlice = decimalDigits.slice(-vis).map(x => {
              let v = parseInt((x || '0'), 10);
              return isNaN(v) ? 0 : v;
            });
            
            const colSlice = numColors.slice(-vis);
            const newHist = [];
            
            for (let i = 0; i < vis; i++) {
              const raw = colSlice[i] || '#666';
              const rawColor = (raw === 'blue' || raw === 'red') ? raw : '#666';
              const prev = newHist.length ? newHist[newHist.length - 1] : null;
              let effColor = rawColor;
              
              if (effColor !== 'blue' && effColor !== 'red') {
                effColor = prev ? prev.effColor : 'blue';
              }
              
              const row = decideRow(prev, decSlice[i], effColor);
              newHist.push({ 
                v: decSlice[i], 
                rawColor: rawColor, 
                effColor: effColor, 
                row: row 
              });
            }
            
            let startGlobalSpan = null;
            
            // COOLDOWN KONTROL√ú: Eƒüer son start'tan bu yana 6 tik ge√ßmediyse yeni start arama
            const ticksSinceLastStart = xzTickCounter - lastStartGlobal;
            if (ticksSinceLastStart >= 6) {
              if (newHist.length >= 3) {
                const n = newHist.length;
                const a = newHist[n - 3].v;
                const b = newHist[n - 2].v;
                const c = newHist[n - 1].v;
                const cond1 = (a % 2 === 0) && (b % 2 === 0) && (c % 2 !== 0);
                const cond2 = (a % 2 !== 0) && (b % 2 !== 0) && (c % 2 === 0);
                
                if (cond1 || cond2) {
                  const firstGlobal = xzTickCounter - vis;
                  startGlobalSpan = { 
                    from: firstGlobal + (n - 3), 
                    to: firstGlobal + (n - 1) 
                  };
                }
              }
            }
            
            return { gridHistory: newHist, startGlobalSpan };
          }
          
          function decideRow(prev, currV, effColor) {
            if (!prev) return (effColor === 'blue') ? 'top' : 'bottom';
            if (currV === prev.v && effColor === prev.effColor) return prev.row;
            if (prev.effColor !== effColor) return (effColor === 'blue') ? 'top' : 'bottom';
            if (effColor === 'blue') return (currV > prev.v) ? 'top' : 'bottom';
            else return (currV < prev.v) ? 'top' : 'bottom';
          }
        `;
        
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        analysisWorker = new Worker(URL.createObjectURL(blob));
        
        analysisWorker.onmessage = function(e) {
          const { type, result } = e.data;
          
          if (type === 'TREND_RESULT') {
            if (result) {
              currentTrendData.direction = result.direction;
              currentTrendData.last3 = result.last3 || [];
              currentTrendData.colors = result.colors || [];
              
              showTrendSignal(result.direction);
              requestAnimationFrame(drawTrendAngle);
              
              if (currentTrendData.arrows && currentTrendData.arrows.length > 0) {
                analyzeUpDownSignalInWorker(currentTrendData.arrows);
              }
            } else {
              currentTrendData.direction = null;
              currentTrendData.last3 = [];
              currentTrendData.colors = [];
              showTrendSignal(null);
              showUpDownSignal(null);
              requestAnimationFrame(drawTrendAngle);
            }
          }
          
          if (type === 'UPDOWN_RESULT') {
            showUpDownSignal(result);
          }
          
          if (type === 'GRID_RESULT') {
            gridHistory = result.gridHistory;
            
            if (result.startGlobalSpan) {
              startGlobalSpan = result.startGlobalSpan;
              lastStartGlobal = xzTickCounter; // FIX: Yeni start bulunduƒüunda kaydet
              trendStartGlobal = result.startGlobalSpan.to;
            }
            
            requestAnimationFrame(() => {
              renderTwoRowGrid();
              renderStartOverlay();
              
              if (analysisWorker && gridHistory.length >= 6 && startGlobalSpan) {
                analysisWorker.postMessage({
                  type: 'ANALYZE_TREND',
                  data: { gridHistory, startGlobalSpan, xzTickCounter }
                });
              }
            });
          }
        };
        
        analysisWorker.onerror = function(error) {
          console.error('Worker hatasƒ±:', error);
          analysisWorker = null;
        };
      }
    }

    function analyzeUpDownSignalInWorker(arrows) {
      if (!analysisWorker) return;
      
      analysisWorker.postMessage({
        type: 'ANALYZE_UPDOWN',
        data: { arrows: arrows }
      });
    }

    // ========== SAYFA G√ñR√úN√úRL√úƒû√ú KONTROL√ú ==========
    function setupVisibilityHandling() {
      const visibilityHandler = function() {
        isPageVisible = !document.hidden;
        
        if (isPageVisible) {
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
          }
          
          requestAnimationFrame(() => {
            renderXYArea();
            renderTwoRowGrid();
            renderStartOverlay();
            drawTrendAngle();
            if (chart) chart.update();
          });
          
          if (isRunning && (!ws || ws.readyState === WebSocket.CLOSED)) {
            startWS();
          }
        } else {
          console.log('Arka planda √ßalƒ±≈üƒ±yor...');
        }
      };
      
      document.addEventListener('visibilitychange', visibilityHandler);
      
      if ('serviceWorker' in navigator && !navigator.serviceWorker.controller) {
        navigator.serviceWorker.register('/service-worker.js').catch(err => {
          console.log('Service Worker kaydƒ± ba≈üarƒ±sƒ±z:', err);
        });
      }
    }

    // ========== AUDIO FONKSƒ∞YONLARI ==========
    function initAudio() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
          console.log('Audio init error:', e);
        }
      }
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
      }
      return audioContext;
    }

    function playUpTrendSound() {
      const ctx = initAudio();
      if (!ctx) return;
      const now = ctx.currentTime;
      const notes = [
        {freq: 261.63, start: 0, duration: 0.3},
        {freq: 329.63, start: 0.25, duration: 0.3},
        {freq: 392.00, start: 0.5, duration: 0.3},
        {freq: 523.25, start: 0.75, duration: 0.5}
      ];
      notes.forEach(function(note) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = note.freq;
        const startTime = now + note.start;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.12, startTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(startTime);
        osc.stop(startTime + note.duration);
      });
    }

    function playDownTrendSound() {
      const ctx = initAudio();
      if (!ctx) return;
      const now = ctx.currentTime;
      const notes = [
        {freq: 392.00, start: 0, duration: 0.3},
        {freq: 329.63, start: 0.25, duration: 0.3},
        {freq: 261.63, start: 0.5, duration: 0.3},
        {freq: 220.00, start: 0.75, duration: 0.5}
      ];
      notes.forEach(function(note) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = note.freq;
        const startTime = now + note.start;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.12, startTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + note.duration);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(startTime);
        osc.stop(startTime + note.duration);
      });
    }

    // ========== AUTO TRADE FONKSƒ∞YONLARI ==========
    function toggleAutoTrade() {
      autoTradeEnabled = !autoTradeEnabled;
      const btn = document.getElementById('autoTradeBtn');
      if (autoTradeEnabled) {
        btn.classList.add('active');
        console.log('Auto Trade A√áIK');
      } else {
        btn.classList.remove('active');
        console.log('Auto Trade KAPALI');
      }
    }

    function executeAutoTrade() {
      if (!autoTradeEnabled || autoTradeInProgress || tradeActive || !currentUpDownSignal) return;
      if (!apiToken || !derivWS || derivWS.readyState !== WebSocket.OPEN) return;
      autoTradeInProgress = true;
      if (currentUpDownSignal === 'UP') {
        console.log('Auto Trade: CALL');
        placeTrade('CALL');
      } else if (currentUpDownSignal === 'DOWN') {
        console.log('Auto Trade: PUT');
        placeTrade('PUT');
      }
      setTimeout(function() {
        autoTradeInProgress = false;
      }, 6000);
    }

    // ========== UP/DOWN Sƒ∞NYAL FONKSƒ∞YONLARI ==========
    function showUpDownSignal(signal) {
      const box = document.getElementById('upDownSignalBox');
      const text = document.getElementById('upDownSignalText');
      box.classList.remove('signal-up', 'signal-down');
      if (signal === 'UP') {
        box.classList.add('signal-up');
        text.textContent = '‚ñ≤ UP';
        currentUpDownSignal = 'UP';
        if (lastUpDownSignal !== 'UP') executeAutoTrade();
        lastUpDownSignal = 'UP';
      } else if (signal === 'DOWN') {
        box.classList.add('signal-down');
        text.textContent = '‚ñº DOWN';
        currentUpDownSignal = 'DOWN';
        if (lastUpDownSignal !== 'DOWN') executeAutoTrade();
        lastUpDownSignal = 'DOWN';
      } else {
        text.textContent = '---';
        currentUpDownSignal = null;
        lastUpDownSignal = null;
      }
    }

    // ========== TREND ANALƒ∞Z FONKSƒ∞YONLARI ==========
    function showTrendSignal(direction) {
      const box = document.getElementById('trendBellBox');
      const label = document.getElementById('trendLabel');
      box.classList.remove('trend-up', 'trend-down');
      if (direction === 'UP') {
        box.classList.add('trend-up');
        label.textContent = 'Trend ‚Üë';
        if (lastTrendSignal !== 'UP') {
          playUpTrendSound();
          lastTrendSignal = 'UP';
        }
      } else if (direction === 'DOWN') {
        box.classList.add('trend-down');
        label.textContent = 'Trend ‚Üì';
        if (lastTrendSignal !== 'DOWN') {
          playDownTrendSound();
          lastTrendSignal = 'DOWN';
        }
      } else {
        label.textContent = 'Trend';
        lastTrendSignal = null;
      }
    }

    function drawTrendAngle() {
      const canvas = document.getElementById('trendAngleCanvas');
      if (!canvas) return;
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);
      const isDark = !document.body.classList.contains('day-mode');
      const width = rect.width;
      const height = rect.height;
      const vzY = height * 0.45;
      
      ctx.strokeStyle = '#FF9900';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(5, vzY);
      ctx.lineTo(width - 5, vzY);
      ctx.stroke();
      
      const arrows = [];
      
      if (currentTrendData.last3 && currentTrendData.last3.length >= 3) {
        const data = currentTrendData.last3;
        const colors = currentTrendData.colors || [];
        const x1 = width * 0.2, x2 = width * 0.5, x3 = width * 0.8;
        const topY = height * 0.2, bottomY = height * 0.65;
        const y1 = topY + (data[0] * 2.5);
        const y2 = bottomY;
        const y3 = topY + ((9 - data[2]) * 2.5);
        
        ctx.strokeStyle = isDark ? '#fff' : '#000';
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.stroke();
        
        const points = [{x: x1, y: y1}, {x: x2, y: y2}, {x: x3, y: y3}];
        points.forEach(function(p, i) {
          ctx.fillStyle = isDark ? '#000' : '#fff';
          ctx.beginPath();
          ctx.arc(p.x, p.y, 7, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = isDark ? '#fff' : '#000';
          ctx.lineWidth = 1.5;
          ctx.stroke();
          ctx.font = 'bold 9px sans-serif';
          ctx.fillStyle = colors[i] === 'blue' ? '#0066ff' : '#cc0000';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(String(data[i]), p.x, p.y);
        });
        
        const arrowSize = 4;
        const dir1 = y2 > y1 ? 1 : -1;
        arrows.push(dir1 > 0 ? 'down' : 'up');
        
        ctx.strokeStyle = dir1 > 0 ? '#ff0000' : '#0066ff';
        ctx.fillStyle = ctx.strokeStyle;
        ctx.lineWidth = 1.5;
        const midX1 = (x1 + x2) / 2 - 4;
        const midY1 = (y1 + y2) / 2;
        ctx.beginPath();
        ctx.moveTo(midX1, midY1 - 6 * dir1);
        ctx.lineTo(midX1, midY1 + 6 * dir1);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(midX1 - arrowSize, midY1 + 3 * dir1);
        ctx.lineTo(midX1, midY1 + 8 * dir1);
        ctx.lineTo(midX1 + arrowSize, midY1 + 3 * dir1);
        ctx.fill();
        
        const dir2 = y3 < y2 ? -1 : 1;
        arrows.push(dir2 < 0 ? 'up' : 'down');
        
        ctx.strokeStyle = dir2 < 0 ? '#0066ff' : '#ff0000';
        ctx.fillStyle = ctx.strokeStyle;
        const midX2 = (x2 + x3) / 2 + 4;
        const midY2 = (y2 + y3) / 2;
        ctx.beginPath();
        ctx.moveTo(midX2, midY2 - 6 * dir2);
        ctx.lineTo(midX2, midY2 + 6 * dir2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(midX2 - arrowSize, midY2 + 3 * dir2);
        ctx.lineTo(midX2, midY2 + 8 * dir2);
        ctx.lineTo(midX2 + arrowSize, midY2 + 3 * dir2);
        ctx.fill();
        
        const generalDir = data[2] > data[0] ? 'up' : (data[2] < data[0] ? 'down' : null);
        if (generalDir) arrows.push(generalDir);
        
        currentTrendData.arrows = arrows;
        
        if (analysisWorker) {
          analysisWorker.postMessage({
            type: 'ANALYZE_UPDOWN',
            data: { arrows: arrows }
          });
        }
      }
    }

    // ========== TEMA FONKSƒ∞YONLARI ==========
    function updateLogos() {
      const headerLogo = document.getElementById('headerLogo');
      const watermark = document.getElementById('chartWatermark');
      const isDark = !document.body.classList.contains('day-mode');
      if (isDark) {
        headerLogo.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg';
        watermark.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/D354DBAF-3EC7-4B5F-ABC1-8EF876797DAA.jpeg';
      } else {
        headerLogo.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/B3F65E6D-3FB0-45E3-A46A-7E788A46DEC7.jpeg';
        watermark.src = 'https://raw.githubusercontent.com/Samday68/Foto-raflar/refs/heads/main/B3F65E6D-3FB0-45E3-A46A-7E788A46DEC7.jpeg';
      }
    }

    function updateChartColors() {
      if (!chart) return;
      const isDark = !document.body.classList.contains('day-mode');
      chart.data.datasets[0].borderColor = isDark ? '#fff' : '#000';
      chart.data.datasets[0].backgroundColor = isDark ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
      chart.options.scales.y.grid.color = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      chart.options.scales.x.grid.color = isDark ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
      chart.options.scales.y.ticks.color = isDark ? '#fff' : '#000';
      chart.options.scales.x.ticks.color = isDark ? '#fff' : '#000';
      chart.update();
    }

    function toggleTheme() {
      const body = document.body;
      const btn = document.getElementById('themeToggle');
      body.classList.toggle('day-mode');
      btn.innerText = body.classList.contains('day-mode') ? '‚òÄÔ∏è' : 'üåô';
      updateLogos();
      updateChartColors();
      renderXYArea();
      drawTrendAngle();
      if (tradeActive) drawTradeChart();
    }

    // ========== TOKEN FONKSƒ∞YONLARI ==========
    function loadSavedToken() {
      const saved = localStorage.getItem('apiToken');
      if (saved) {
        document.getElementById('apiInput').value = saved;
        document.getElementById('saveCheckbox').checked = true;
      }
    }

    function toggleSaveToken() {
      const checkbox = document.getElementById('saveCheckbox');
      const input = document.getElementById('apiInput');
      if (checkbox.checked) {
        if (input.value.trim()) {
          localStorage.setItem('apiToken', input.value.trim());
        }
      } else {
        localStorage.removeItem('apiToken');
      }
    }

    // ========== KONTROL FONKSƒ∞YONLARI ==========
    function toggleStartStop() {
      isRunning = !isRunning;
      const btn = document.getElementById('startStopBtn');
      const text = document.getElementById('startStopText');
      if (isRunning) {
        btn.classList.remove('stopped');
        text.innerText = 'START';
        startWS();
      } else {
        btn.classList.add('stopped');
        text.innerText = 'STOP';
        if (ws) ws.close();
      }
    }

    function toggleGraph() {
      if (currentGraph === 'XZ') currentGraph = 'ZZ';
      else if (currentGraph === 'ZZ') currentGraph = 'Z.Z';
      else currentGraph = 'XZ';
      document.getElementById('graphToggle').innerText = currentGraph;
      if (chart) chart.update();
      renderXYArea();
      renderTwoRowGrid();
      renderStartOverlay();
    }

    function selectPair(pair) {
      currentPair = pair;
      document.querySelectorAll('.pair-btn').forEach(function(b) {
        b.classList.remove('active');
      });
      document.querySelector('.pair-btn[data-pair="' + pair + '"]').classList.add('active');
      if (ws) ws.close();
      prices = [];
      digits = [];
      decimalDigits = [];
      combinedDigits = [];
      wormLinesTop = [];
      numColors = [];
      document.getElementById('numbersTop').innerHTML = '';
      gridHistory = [];
      startCooldown = 0;
      startGlobalSpan = null;
      lastStartGlobal = -100; // FIX: Sƒ±fƒ±rla
      xzTickCounter = 0;
      currentTrendData = { direction: null, last3: [], colors: [], arrows: [] };
      lastTrendSignal = null;
      trendStartGlobal = null;
      showTrendSignal(null);
      showUpDownSignal(null);
      renderTwoRowGrid();
      renderStartOverlay();
      renderXYArea();
      drawTrendAngle();
      if (isRunning) startWS();
    }

    // ========== ARKA PLANDA VERƒ∞ ƒ∞≈ûLEME ==========
    function processDataInBackground(msg) {
      const d = JSON.parse(msg.data);
      
      if (d.tick) {
        const priceStr = d.tick.quote.toString();
        const price = parseFloat(d.tick.quote);
        
        prices.push(price);
        if (prices.length > 50) prices.shift();
        
        const parts = priceStr.split('.');
        const intPart = parts[0];
        let decPart = parts[1] || '0';
        if (decPart.length === 1) decPart = decPart + '0';
        
        const lastTwo = intPart.slice(-2);
        digits.push(lastTwo);
        if (digits.length > 50) digits.shift();
        
        const lastDec = decPart.charAt(decPart.length - 1) || '0';
        decimalDigits.push(lastDec);
        if (decimalDigits.length > 50) decimalDigits.shift();
        
        xzTickCounter++;
        
        requestAnimationFrame(() => {
          const priceEl = document.getElementById('price');
          let displayPrice = intPart;
          if (decPart && decPart !== '00') {
            displayPrice = intPart + ',' + decPart;
          } else {
            displayPrice = intPart + ',00';
          }
          priceEl.innerText = displayPrice;
        });
      }
    }

    // ========== ANA VERƒ∞ ƒ∞≈ûLEME FONKSƒ∞YONU ==========
    function processWebSocketMessage(msg) {
      const now = performance.now();
      if (now - lastRenderTime < renderThrottle) {
        pendingUpdates.push(msg);
        if (!isProcessingUpdates) {
          setTimeout(processPendingUpdates, renderThrottle);
        }
        return;
      }
      
      lastRenderTime = now;
      const d = JSON.parse(msg.data);
      
      if (d.history) {
        d.history.prices.forEach(p => {
          const priceStr = String(p);
          const price = parseFloat(p);
          prices.push(price);
          if (prices.length > 20) prices.shift();
          
          const parts = priceStr.split('.');
          const intPart = parts[0];
          let decPart = parts[1] || '0';
          if (decPart.length === 1) decPart = decPart + '0';
          
          const lastTwo = intPart.slice(-2);
          digits.push(lastTwo);
          if (digits.length > 20) digits.shift();
          
          const lastDec = decPart.charAt(decPart.length - 1) || '0';
          decimalDigits.push(lastDec);
          if (decimalDigits.length > 20) decimalDigits.shift();
          
          xzTickCounter++;
          
          const lastInt = intPart.slice(-1);
          const firstDec = decPart.charAt(0) || '0';
          combinedDigits.push(lastInt + ',' + firstDec);
          if (combinedDigits.length > 20) combinedDigits.shift();
        });
      }
      
      if (d.tick) {
        const priceStr = d.tick.quote.toString();
        const price = parseFloat(d.tick.quote);
        prices.push(price);
        if (prices.length > 20) prices.shift();
        
        const parts = priceStr.split('.');
        const intPart = parts[0];
        let decPart = parts[1] || '0';
        if (decPart.length === 1) decPart = decPart + '0';
        
        const lastTwo = intPart.slice(-2);
        digits.push(lastTwo);
        if (digits.length > 20) digits.shift();
        
        const lastDec = decPart.charAt(decPart.length - 1) || '0';
        decimalDigits.push(lastDec);
        if (decimalDigits.length > 20) decimalDigits.shift();
        
        xzTickCounter++;
        
        const lastInt = intPart.slice(-1);
        const firstDec = decPart.charAt(0) || '0';
        combinedDigits.push(lastInt + ',' + firstDec);
        if (combinedDigits.length > 20) combinedDigits.shift();
        
        requestAnimationFrame(() => {
          const priceEl = document.getElementById('price');
          let displayPrice = intPart;
          if (decPart && decPart !== '00') {
            displayPrice = intPart + ',' + decPart;
          } else {
            displayPrice = intPart + ',00';
          }
          priceEl.innerText = displayPrice;
          
          if (prices.length > 1) {
            const prev = prices[prices.length - 2];
            if (price > prev) priceEl.style.background = 'blue';
            else if (price < prev) priceEl.style.background = 'red';
            else priceEl.style.background = '#0b57d0';
          }
        });
      }
      
      if (analysisWorker) {
        analysisWorker.postMessage({
          type: 'PROCESS_GRID',
          data: { 
            decimalDigits, 
            numColors, 
            xzTickCounter,
            lastStartGlobal // FIX: Cooldown i√ßin g√∂nder
          }
        });
      }
      
      requestAnimationFrame(() => {
        updateNumbersTop();
        updateWorm();
        renderWormLines('numbersTop', wormLinesTop.slice(-11));
        
        if (chart) {
          const last11 = prices.slice(-11);
          chart.data.datasets[0].data = last11;
          chart.data.datasets[0].pointBackgroundColor = last11.map((p, i) => {
            if (i === 0) return 'gray';
            if (p > last11[i - 1]) return 'blue';
            if (p < last11[i - 1]) return 'red';
            return 'gray';
          });
          chart.update();
        }
      });
      
      requestAnimationFrame(renderXYArea);
    }

    function processPendingUpdates() {
      if (pendingUpdates.length === 0) {
        isProcessingUpdates = false;
        return;
      }
      
      isProcessingUpdates = true;
      const msg = pendingUpdates.shift();
      processWebSocketMessage(msg);
      
      if (pendingUpdates.length > 0) {
        setTimeout(processPendingUpdates, renderThrottle);
      } else {
        isProcessingUpdates = false;
      }
    }

    // ========== WEBSOCKET ==========
    function startWS() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.close();
      }
      
      clearTimeout(wsReconnectTimer);
      
      ws = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
      
      ws.onopen = function() {
        console.log('WS baƒülantƒ±sƒ± a√ßƒ±ldƒ±');
        ws.send(JSON.stringify({ 
          ticks_history: currentPair, 
          end: "latest", 
          count: 20, 
          subscribe: 1 
        }));
      };
      
      ws.onmessage = function(msg) {
        if (!isPageVisible) {
          processDataInBackground(msg);
          return;
        }
        
        processWebSocketMessage(msg);
      };
      
      ws.onerror = function(error) {
        console.error('WS hatasƒ±:', error);
      };
      
      ws.onclose = function() {
        console.log('WS baƒülantƒ±sƒ± kapandƒ±');
        if (isRunning && isPageVisible) {
          wsReconnectTimer = setTimeout(startWS, 3000);
        }
      };
    }

    // ========== API FONKSƒ∞YONLARI ==========
    function connectAPI() {
      apiToken = document.getElementById('apiInput').value.trim();
      if (!apiToken) {
        alert('L√ºtfen ge√ßerli bir API token girin!');
        return;
      }
      derivWS = new WebSocket('wss://ws.binaryws.com/websockets/v3?app_id=1089');
      derivWS.onopen = function() {
        derivWS.send(JSON.stringify({ authorize: apiToken }));
      };
      derivWS.onmessage = function(msg) {
        const data = JSON.parse(msg.data);
        if (data.authorize) {
          alert('API Baƒülantƒ±sƒ± Ba≈üarƒ±lƒ±!');
          if (data.authorize.balance) {
            document.getElementById('balanceValue').innerText = '$ ' + parseFloat(data.authorize.balance).toFixed(2);
          }
          derivWS.send(JSON.stringify({ balance: 1, subscribe: 1 }));
        }
        if (data.balance) {
          document.getElementById('balanceValue').innerText = '$ ' + parseFloat(data.balance.balance).toFixed(2);
        }
        if (data.proposal_open_contract) {
          const contract = data.proposal_open_contract;
          if (tradeActive && contract.tick_stream) {
            const ticks = contract.tick_stream;
            if (tradeData.length === 0 && ticks.length > 0) {
              entrySpot = parseFloat(ticks[0].tick);
              barrier = parseFloat(contract.barrier || entrySpot);
              tradeData = [entrySpot];
              document.getElementById('tradeChart').style.display = 'block';
            }
            if (ticks.length > tradeData.length && tradeData.length < 6) {
              for (let i = tradeData.length; i < Math.min(ticks.length, 6); i++) {
                tradeData.push(parseFloat(ticks[i].tick));
              }
              drawTradeChart();
            }
          }
          if (contract.status === 'won' || contract.status === 'lost') {
            if (contract.exit_tick) {
              exitSpot = parseFloat(contract.exit_tick);
            }
            const profit = parseFloat(contract.profit || 0);
            document.getElementById('profitValue').innerText = (profit >= 0 ? '$ +' : '$ ') + profit.toFixed(2);
            drawTradeChart();
            tradeActive = false;
          }
        }
        if (data.error) {
          alert('API Hatasƒ±: ' + data.error.message);
        }
      };
    }

    function placeTrade(type) {
      if (!apiToken || !derivWS || derivWS.readyState !== WebSocket.OPEN) {
        alert('√ñnce API baƒülantƒ±sƒ± yapƒ±n!');
        return;
      }
      const stakeInput = document.getElementById('stakeInput');
      let stake = parseFloat(stakeInput.value);
      if (isNaN(stake) || stake < 0.35) {
        alert('Minimum stake 0.35 USD olmalƒ±!');
        stakeInput.value = '1';
        return;
      }
      const proposal = {
        proposal: 1,
        amount: stake,
        basis: 'stake',
        contract_type: type,
        currency: 'USD',
        duration: 5,
        duration_unit: 't',
        symbol: currentPair
      };
      derivWS.send(JSON.stringify(proposal));
      const handleProposal = function(msg) {
        const data = JSON.parse(msg.data);
        if (data.proposal) {
          const proposalId = data.proposal.id;
          derivWS.send(JSON.stringify({ buy: proposalId, price: stake }));
        }
        if (data.buy) {
          contractId = data.buy.contract_id;
          tradeActive = true;
          tradeType = type;
          entrySpot = 0;
          exitSpot = 0;
          barrier = 0;
          tradeData = [];
          derivWS.send(JSON.stringify({ proposal_open_contract: 1, contract_id: contractId, subscribe: 1 }));
          derivWS.removeEventListener('message', handleProposal);
        }
        if (data.error) {
          alert('Trade Hatasƒ±: ' + data.error.message);
          derivWS.removeEventListener('message', handleProposal);
        }
      };
      derivWS.addEventListener('message', handleProposal);
    }

    // ========== TRADE CHART ==========
    function drawTradeChart() {
      const canvas = document.getElementById('tradeCanvas');
      if (!canvas || tradeData.length === 0) return;
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);
      const isDark = !document.body.classList.contains('day-mode');
      const width = rect.width;
      const height = rect.height;
      const padding = 12;
      const allValues = tradeData.concat([barrier]);
      const minVal = Math.min.apply(null, allValues);
      const maxVal = Math.max.apply(null, allValues);
      const range = maxVal - minVal || 0.001;
      const marginPercent = 0.1;
      const adjustedMin = minVal - (range * marginPercent);
      const adjustedMax = maxVal + (range * marginPercent);
      const adjustedRange = adjustedMax - adjustedMin;
      function getY(val) {
        return height - padding - ((val - adjustedMin) / adjustedRange) * (height - 2 * padding);
      }
      if (tradeData.length > 0) {
        ctx.strokeStyle = '#FF8C00';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 2]);
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.font = '7px sans-serif';
        ctx.fillStyle = '#FF8C00';
        ctx.textAlign = 'center';
        ctx.fillText('Entry', padding, padding - 2);
      }
      if (barrier > 0) {
        const barrierY = getY(barrier);
        ctx.strokeStyle = isDark ? '#fff' : '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, barrierY);
        ctx.lineTo(width - padding, barrierY);
        ctx.stroke();
        ctx.font = '7px sans-serif';
        ctx.fillStyle = isDark ? '#fff' : '#000';
        ctx.textAlign = 'left';
        ctx.fillText('Barrier', padding + 2, barrierY - 3);
      }
      if (tradeData.length > 0) {
        const stepX = (width - 2 * padding) / 5;
        ctx.strokeStyle = '#6B8CAE';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        tradeData.forEach(function(val, i) {
          const x = padding + (i * stepX);
          const y = getY(val);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
        tradeData.forEach(function(val, i) {
          if (i < 1) return;
          const x = padding + (i * stepX);
          const y = getY(val);
          ctx.fillStyle = '#6B8CAE';
          ctx.beginPath();
          ctx.arc(x, y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
        if (tradeData.length === 6) {
          const exitX = padding + (5 * stepX);
          ctx.strokeStyle = '#FF8C00';
          ctx.lineWidth = 1.5;
          ctx.setLineDash([4, 2]);
          ctx.beginPath();
          ctx.moveTo(exitX, padding);
          ctx.lineTo(exitX, height - padding);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.font = '7px sans-serif';
          ctx.fillStyle = '#FF8C00';
          ctx.textAlign = 'center';
          ctx.fillText('Exit', exitX, padding - 2);
        }
      }
      if (tradeData.length === 6 && exitSpot > 0) {
        const won = (tradeType === 'CALL' && exitSpot > barrier) || (tradeType === 'PUT' && exitSpot < barrier);
        ctx.fillStyle = won ? 'rgba(76, 175, 80, 0.15)' : 'rgba(244, 67, 54, 0.15)';
        ctx.fillRect(0, 0, width, height);
      }
    }

    // ========== WORM FONKSƒ∞YONLARI ==========
    function updateWorm() {
      if (prices.length < 20) return;
      const last20 = prices.slice(-20);
      const max = Math.max.apply(null, last20.slice(0, -1));
      const min = Math.min.apply(null, last20.slice(0, -1));
      const last = last20[last20.length - 1];
      let color = 'lightgreen';
      if (last > max) color = 'blue';
      else if (last < min) color = 'red';
      wormLinesTop.push(color);
      if (wormLinesTop.length > 20) wormLinesTop.shift();
    }

    function renderWormLines(containerId, wormArray) {
      const c = document.getElementById(containerId);
      c.querySelectorAll('.worm-line').forEach(function(e) { e.remove(); });
      const boxes = c.querySelectorAll('.num-box');
      boxes.forEach(function(box, idx) {
        if (!wormArray[idx]) return;
        const line = document.createElement('div');
        line.className = 'worm-line';
        line.style.width = box.offsetWidth + 'px';
        line.style.left = box.offsetLeft + 'px';
        line.style.top = (box.offsetTop + box.offsetHeight + 0.2) + 'px';
        line.style.borderTopColor = wormArray[idx];
        c.appendChild(line);
      });
    }

    // ========== XY AREA ==========
    function renderXYArea() {
      const canvas = document.getElementById('xyCanvas');
      if (!canvas) return;
      const box = document.getElementById('xyBox');
      const rect = box.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, rect.width, rect.height);
      if (currentGraph !== 'XZ') return;
      const vis = Math.min(11, decimalDigits.length);
      if (vis < 2) return;
      const decSlice = decimalDigits.slice(-vis);
      const colorSlice = numColors.slice(-vis);
      const isDark = !document.body.classList.contains('day-mode');
      const values = decSlice.map(function(d) {
        let v = parseInt((d || '0'), 10);
        if (isNaN(v)) v = 0;
        if (v === 0) v = 10;
        return v;
      });
      const width = rect.width;
      const height = rect.height;
      const marginX = 32;
      const marginTop = 14;
      const marginBottom = 24;
      const stepX = (width - 2 * marginX) / (vis - 1);
      const xs = [];
      for (let i = 0; i < vis; i++) xs.push(marginX + i * stepX);
      const baseY = height / 2;
      const maxAmp = (height / 2) - marginTop - marginBottom;
      const unitY = maxAmp / 10;
      function pointY(idx) {
        const v = values[idx];
        const col = colorSlice[idx];
        if (col === 'blue') return baseY - v * unitY;
        if (col === 'red') return baseY + v * unitY;
        return baseY;
      }
      ctx.strokeStyle = isDark ? '#fff' : '#000';
      ctx.lineWidth = 2.0;
      ctx.beginPath();
      ctx.moveTo(marginX - 10, baseY);
      ctx.lineTo(width - marginX + 10, baseY);
      ctx.stroke();
      const splitIndex = vis - 6;
      const splitX = xs[splitIndex] - stepX * 0.15;
      ctx.lineWidth = 2.0;
      ctx.strokeStyle = '#0b57d0';
      ctx.beginPath();
      ctx.moveTo(splitX, marginTop - 6);
      ctx.lineTo(splitX, baseY);
      ctx.stroke();
      ctx.strokeStyle = '#d93025';
      ctx.beginPath();
      ctx.moveTo(splitX, baseY);
      ctx.lineTo(splitX, height - marginBottom + 12);
      ctx.stroke();
      ctx.font = '10px sans-serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for (let v = 1; v <= 10; v++) {
        const yUp = baseY - v * unitY;
        const yDn = baseY + v * unitY;
        if (yUp > marginTop - 4) {
          ctx.fillStyle = '#0b57d0';
          ctx.fillText(String(v), marginX - 16, yUp);
        }
        if (yDn < height - marginBottom + 6) {
          ctx.fillStyle = '#d93025';
          ctx.fillText(String(v), marginX - 16, yDn);
        }
      }
      ctx.strokeStyle = '#777';
      ctx.lineWidth = 2.0;
      const startIdx = vis - 6;
      ctx.beginPath();
      for (let i = startIdx; i < vis; i++) {
        const x = xs[i];
        const y = pointY(i);
        if (i === startIdx) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = 'bold 15px sans-serif';
      for (let i = 0; i < vis; i++) {
        const x = xs[i];
        const y = pointY(i);
        const col = colorSlice[i];
        ctx.fillStyle = (col === 'blue' ? '#0b57d0' : (col === 'red' ? '#d93025' : '#666'));
        const shown = (values[i] === 10 ? 0 : values[i]);
        ctx.fillText(String(shown), x, y);
      }
      ctx.strokeStyle = isDark ? '#40E0D0' : '#000';
      ctx.lineWidth = 2.3;
      function drawVZ(i, j) {
        const v1 = values[i], v2 = values[j];
        const c1 = colorSlice[i], c2 = colorSlice[j];
        if (c1 !== c2) return;
        if (c1 !== 'blue' && c1 !== 'red') return;
        if (Math.abs(v1 - v2) !== 1) return;
        const x1 = xs[i], x2 = xs[j];
        const y1 = pointY(i), y2 = pointY(j);
        const yMid = (y1 + y2) / 2;
        const extra = 10;
        ctx.beginPath();
        ctx.moveTo(x1 - extra, yMid);
        ctx.lineTo(x2 + extra, yMid);
        ctx.stroke();
      }
      for (let i = 0; i < vis - 1; i++) drawVZ(i, i + 1);
      const winStart = Math.max(0, vis - 6);
      for (let i = winStart; i < vis; i++) {
        for (let j = i + 2; j < vis; j++) drawVZ(i, j);
      }
      const lastLocal = vis - 1;
      const lastVal = values[lastLocal];
      const lastCol = colorSlice[lastLocal];
      const pairs = [];
      for (let k = 1; k <= 5; k++) {
        const idx = lastLocal - k;
        if (idx < 0) break;
        const prevCol = colorSlice[idx];
        if (Math.abs(lastVal - values[idx]) === 1 && lastCol !== prevCol && lastCol !== '#666' && prevCol !== '#666') {
          pairs.push(idx);
        }
      }
      if (pairs.length > 0) {
        ctx.strokeStyle = isDark ? '#fff' : '#000';
        ctx.lineWidth = 2;
        const radius = 10;
        const xL = xs[lastLocal], yL = pointY(lastLocal);
        ctx.beginPath();
        ctx.arc(xL, yL, radius, 0, Math.PI * 2);
        ctx.stroke();
        pairs.forEach(function(idx) {
          const x = xs[idx], y = pointY(idx);
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.stroke();
        });
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const shownLast = (values[lastLocal] === 10 ? 0 : values[lastLocal]);
        ctx.fillStyle = (lastCol === 'blue' ? '#0b57d0' : (lastCol === 'red' ? '#d93025' : '#666'));
        ctx.fillText(String(shownLast), xL, yL);
        pairs.forEach(function(idx) {
          const x = xs[idx], y = pointY(idx);
          const col = colorSlice[idx];
          const shown = (values[idx] === 10 ? 0 : values[idx]);
          ctx.fillStyle = (col === 'blue' ? '#0b57d0' : (col === 'red' ? '#d93025' : '#666'));
          ctx.fillText(String(shown), x, y);
        });
      }
    }

    // ========== GRID FONKSƒ∞YONLARI ==========
    function isEven(n) {
      return (n % 2) === 0;
    }

    function renderTwoRowGrid() {
      const topRow = document.getElementById('gridTopRow');
      const botRow = document.getElementById('gridBottomRow');
      const dividerLine = document.getElementById('gridDividerLine');
      if (!topRow || !botRow || !dividerLine) return;
      topRow.innerHTML = '';
      botRow.innerHTML = '';
      const vis = gridHistory.length;
      if (vis === 0) {
        dividerLine.style.width = '0px';
        return;
      }
      for (let i = 0; i < vis; i++) {
        const item = gridHistory[i];
        const cellTop = document.createElement('div');
        cellTop.className = 'grid-cell grid-top';
        const cellBot = document.createElement('div');
        cellBot.className = 'grid-cell grid-bottom';
        
        // D√úZELTME: Doƒüru renk kodlarƒ±nƒ± kullan
        let displayColor;
        if (item.rawColor === 'blue') {
          displayColor = '#0b57d0';
        } else if (item.rawColor === 'red') {
          displayColor = '#d93025';
        } else {
          displayColor = '#666';
        }
        
        if (item.row === 'top') {
          cellTop.style.color = displayColor;
          cellTop.textContent = String(item.v);
          cellBot.textContent = '';
        } else {
          cellBot.style.color = displayColor;
          cellBot.textContent = String(item.v);
          cellTop.textContent = '';
        }
        topRow.appendChild(cellTop);
        botRow.appendChild(cellBot);
      }
      const firstCell = topRow.querySelector('.grid-cell');
      const cellW = firstCell ? firstCell.getBoundingClientRect().width : 36;
      dividerLine.style.width = (vis * cellW) + 'px';
    }

    function renderStartOverlay() {
      document.querySelectorAll('.start-box').forEach(function(e) { e.remove(); });
      if (!startGlobalSpan) return;
      if (currentGraph !== 'XZ') return;
      const wrap = document.getElementById('gridWrap');
      const topRow = document.getElementById('gridTopRow');
      const botRow = document.getElementById('gridBottomRow');
      if (!wrap || !topRow || !botRow) return;
      const topCells = topRow.querySelectorAll('.grid-cell');
      const botCells = botRow.querySelectorAll('.grid-cell');
      const vis = topCells.length;
      if (vis === 0) return;
      const firstGlobal = xzTickCounter - vis;
      const fromLocal = startGlobalSpan.from - firstGlobal;
      const toLocal = startGlobalSpan.to - firstGlobal;
      if (fromLocal < 0 || toLocal >= vis) return;
      const c1 = topCells[fromLocal];
      const c2 = topCells[toLocal];
      const b1 = botCells[fromLocal];
      const b2 = botCells[toLocal];
      if (!c1 || !c2 || !b1 || !b2) return;
      const rWrap = wrap.getBoundingClientRect();
      const r1 = c1.getBoundingClientRect();
      const r2 = c2.getBoundingClientRect();
      const rb1 = b1.getBoundingClientRect();
      const rb2 = b2.getBoundingClientRect();
      const left = Math.min(r1.left, rb1.left) - rWrap.left;
      const right = Math.max(r2.right, rb2.right) - rWrap.left;
      const top = Math.min(r1.top, rb1.top) - rWrap.top;
      const bottom = Math.max(r2.bottom, rb2.bottom) - rWrap.top;
      const box = document.createElement('div');
      box.className = 'start-box';
      box.style.left = (left - 2) + 'px';
      box.style.top = (top - 2) + 'px';
      box.style.width = (right - left + 4) + 'px';
      box.style.height = (bottom - top + 4) + 'px';
      const label = document.createElement('div');
      label.className = 'start-label';
      label.textContent = 'start';
      box.appendChild(label);
      wrap.appendChild(box);
    }

    function updateNumbersTop() {
      const row = document.getElementById('numbersTop');
      if (!row) return;
      
      let html = '';
      numColors = [];
      
      const activeArr = (currentGraph === 'XZ' ? decimalDigits : 
                        (currentGraph === 'ZZ' ? digits : combinedDigits));
      const sliceArr = activeArr.slice(-11);
      
      for (let i = 0; i < sliceArr.length; i++) {
        const globalIndex = activeArr.length - 11 + i;
        const up = globalIndex > 0 && prices[globalIndex] > prices[globalIndex - 1];
        const down = globalIndex > 0 && prices[globalIndex] < prices[globalIndex - 1];
        const color = up ? 'blue' : (down ? 'red' : '#666');
        numColors.push(color);
        
        const text = (currentGraph === 'Z.Z') ? 
                    (sliceArr[i] || '').replace(',', '.') : 
                    (sliceArr[i] || '0');
        
        html += `<div class="num-box" style="background:${color}">${text}</div>`;
      }
      
      row.innerHTML = html;
    }

    // ========== CHART OLU≈ûTURMA ==========
    function initChart() {
      const ctx = document.getElementById('chart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: Array.from({ length: 11 }, function(_, i) { return (i + 1).toString(); }),
          datasets: [{
            data: Array(11).fill(null),
            borderColor: '#fff',
            borderWidth: 1.5,
            backgroundColor: 'rgba(255,255,255,0.05)',
            pointBackgroundColor: Array(11).fill('#fff'),
            pointRadius: 2,
            pointHoverRadius: 3
          }]
        },
        options: {
          plugins: { legend: { display: false }, tooltip: { enabled: false } },
          scales: {
            y: { 
              beginAtZero: false, 
              grid: { color: 'rgba(255,255,255,0.1)' }, 
              ticks: { color: '#fff' } 
            },
            x: { 
              grid: { color: 'rgba(255,255,255,0.1)' }, 
              ticks: { color: '#fff' } 
            }
          },
          animation: false,
          maintainAspectRatio: false
        },
        plugins: [{
          afterDatasetsDraw: function(chartInstance) {
            const ctx = chartInstance.ctx;
            const meta = chartInstance.getDatasetMeta(0);
            const isDark = !document.body.classList.contains('day-mode');
            const decs = decimalDigits.slice(-11);
            const colors = numColors.slice(-11);
            const values = decs.map(function(d) {
              let v = parseInt((d || '0'), 10);
              if (isNaN(v)) v = 0;
              return v;
            });
            for (let i = 0; i < values.length - 1; i++) {
              const v1 = values[i];
              const v2 = values[i + 1];
              const c1 = colors[i];
              const c2 = colors[i + 1];
              if (Math.abs(v1 - v2) !== 1) continue;
              const pt1 = meta.data[i];
              const pt2 = meta.data[i + 1];
              if (!pt1 || !pt2) continue;
              const midX = (pt1.x + pt2.x) / 2;
              const midY = (pt1.y + pt2.y) / 2;
              ctx.strokeStyle = isDark ? '#40E0D0' : '#000';
              ctx.lineWidth = 0.9;
              ctx.beginPath();
              ctx.moveTo(midX - 18, midY);
              ctx.lineTo(midX + 18, midY);
              ctx.stroke();
              ctx.font = 'bold 9px sans-serif';
              ctx.fillStyle = isDark ? '#40E0D0' : '#000';
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText('VZ', midX, midY - 10);
              let arrowColor = '';
              if (c1 === c2) {
                if (c1 === 'blue') arrowColor = v2 > v1 ? 'blue' : 'red';
                else if (c1 === 'red') arrowColor = v2 < v1 ? 'blue' : 'red';
              } else {
                if (c1 === 'blue' && c2 === 'red') arrowColor = v1 < v2 ? 'red' : 'blue';
                else if (c1 === 'red' && c2 === 'blue') arrowColor = v2 > v1 ? 'blue' : 'red';
              }
              if (!arrowColor) continue;
              const arrowX = midX + 35;
              const arrowSize = 7;
              const stemLength = 16;
              ctx.strokeStyle = arrowColor;
              ctx.fillStyle = arrowColor;
              ctx.lineWidth = 2;
              if (arrowColor === 'blue') {
                ctx.beginPath();
                ctx.moveTo(arrowX - stemLength * 0.707, midY + stemLength * 0.707);
                ctx.lineTo(arrowX, midY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(arrowX, midY);
                ctx.lineTo(arrowX - arrowSize, midY);
                ctx.lineTo(arrowX, midY + arrowSize);
                ctx.closePath();
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.moveTo(arrowX - stemLength * 0.707, midY - stemLength * 0.707);
                ctx.lineTo(arrowX, midY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(arrowX, midY);
                ctx.lineTo(arrowX - arrowSize, midY);
                ctx.lineTo(arrowX, midY - arrowSize);
                ctx.closePath();
                ctx.fill();
              }
            }
            ctx.font = '900 15px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            const digs = digits.slice(-11);
            const combs = combinedDigits.slice(-11);
            const worms = wormLinesTop.slice(-11);
            meta.data.forEach(function(pt, i) {
              let t = '';
              if (currentGraph === 'XZ') t = decs[i] || '';
              else if (currentGraph === 'ZZ') t = digs[i] || '';
              else t = (combs[i] || '').replace(',', '.');
              if (pt && pt.x !== undefined) {
                let fillColor = colors[i] || '#000';
                if (fillColor === 'blue') fillColor = '#6A9FFF';
                ctx.fillStyle = fillColor;
                ctx.fillText(t, pt.x, pt.y - 2);
                const wormColor = worms[i];
                if (wormColor === 'blue' || wormColor === 'red') {
                  ctx.strokeStyle = wormColor;
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.moveTo(pt.x - 5, pt.y - 2);
                  ctx.lineTo(pt.x + 5, pt.y - 2);
                  ctx.stroke();
                }
              }
            });
            const last = meta.data[meta.data.length - 1];
            if (last && last.x !== undefined) {
              ctx.strokeStyle = isDark ? '#40E0D0' : '#000';
              ctx.lineWidth = 0.5;
              ctx.beginPath();
              ctx.moveTo(chartInstance.scales.x.left, last.y);
              ctx.lineTo(last.x, last.y);
              ctx.stroke();
            }
          }
        }]
      });
    }

    // ========== ZAMAN ==========
    function updateTime() {
      const now = new Date();
      const hh = now.getUTCHours().toString().padStart(2, '0');
      const mm = now.getUTCMinutes().toString().padStart(2, '0');
      const ss = now.getUTCSeconds().toString().padStart(2, '0');
      document.getElementById('time').innerText = 'GMT ' + hh + ':' + mm + ':' + ss;
    }

    // ========== TEMƒ∞ZLEME FONKSƒ∞YONU ==========
    function cleanup() {
      if (analysisWorker) {
        analysisWorker.terminate();
        analysisWorker = null;
      }
      
      if (ws) {
        ws.close();
        ws = null;
      }
      
      if (derivWS) {
        derivWS.close();
        derivWS = null;
      }
      
      clearTimeout(wsReconnectTimer);
      
      pendingUpdates = [];
      isProcessingUpdates = false;
    }

    // ========== BA≈ûLATMA ==========
    document.addEventListener('DOMContentLoaded', function() {
      // Worker'ƒ± olu≈ütur
      createAnalysisWorker();
      
      // G√∂r√ºn√ºrl√ºk kontrol√ºn√º ayarla
      setupVisibilityHandling();
      
      // Chart'ƒ± ba≈ülat
      initChart();
      
      // Event listener'larƒ± ekle
      document.getElementById('themeToggle').addEventListener('click', toggleTheme);
      document.getElementById('graphToggle').addEventListener('click', toggleGraph);
      document.getElementById('startStopBtn').addEventListener('click', toggleStartStop);
      document.getElementById('connectBtn').addEventListener('click', connectAPI);
      document.getElementById('saveCheckbox').addEventListener('change', toggleSaveToken);
      document.getElementById('autoTradeBtn').addEventListener('click', toggleAutoTrade);
      document.getElementById('callBtn').addEventListener('click', function() { placeTrade('CALL'); });
      document.getElementById('putBtn').addEventListener('click', function() { placeTrade('PUT'); });
      
      // Pair butonlarƒ±
      document.querySelectorAll('.pair-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
          selectPair(this.getAttribute('data-pair'));
        });
      });
      
      // Zaman g√ºncelleme
      setInterval(updateTime, 1000);
      updateTime();
      
      // WebSocket ba≈ülat
      startWS();
      
      // Token y√ºkle
      loadSavedToken();
      
      // Logolarƒ± g√ºncelle
      updateLogos();
      
      // Audio init
      document.body.addEventListener('click', function initAudioOnce() {
        initAudio();
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
      }, { once: true });
      
      document.body.addEventListener('touchstart', function() {
        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume();
        }
      }, { passive: true });
      
      // Resize i√ßin throttle
      let resizeTimeout;
      window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
          if (isPageVisible) {
            requestAnimationFrame(() => {
              renderXYArea();
              renderStartOverlay();
              renderTwoRowGrid();
              drawTrendAngle();
            });
          }
        }, 100);
      });
      
      // Sayfa kapanƒ±rken temizlik
      window.addEventListener('beforeunload', cleanup);
      window.addEventListener('pagehide', cleanup);
    });
  </script>
</body>
</html>
